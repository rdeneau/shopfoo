namespace Shopfoo.Effects

open Shopfoo.Common
open Shopfoo.Domain.Types.Errors

/// <summary>
/// A chain of effects containing the program instructions and returning a value of type <typeparamref name="'ret"/>.
/// </summary>
/// <remarks>
/// <para>
/// A program is written using the <c>program</c> computation expression defined in the <c>ProgramBuilder</c> module below.
/// An interpreter is needed to evaluate the program - it's defined in the <c>Infrastructure</c> layer.
/// </para>
/// <para>
/// It's one of the functional patterns to handle dependency injection, called <em>Dependency Interpretation</em>.
/// <br/> 🔗 https://fsharpforfunandprofit.com/posts/dependencies-4/
/// </para>
/// <para>
/// The purpose is to have a domain pure, free from side effects.
/// <br/> 🔗 https://enterprisecraftsmanship.com/posts/domain-model-purity-completeness/
/// </para>
/// <para>
/// In Haskell, the <c>Program</c> union type has an equivalent called the <em>Free monad</em>:
/// <br/> - the <c>Stop</c> case is called <c>Pure</c>,
/// <br/> - the <c>Effect</c> case is called <c>Free</c> and contains a specific effect type which is an instance of the functor type class,
/// whereas the <c>Program.Effect</c> can contain any implementation of the <c>IProgramEffect</c> interface
/// that defines an abstract functor.
/// <br/> 🔗 https://blog.ploeh.dk/2017/07/04/pure-times-in-f/
/// <br/> 🔗 https://blog.ploeh.dk/2017/08/07/f-free-monad-recipe/
/// </para>
/// <para>
/// So, the <c>Program</c> type is open to any effects, but we end up with a program without knowing which effect(s) it contains,
/// whereas the <c>Free</c> type is closed on a specific range of effects, bringing stronger type safety at the interpreter level.
/// </para>
/// <para>
/// The <c>Program</c> type is inspired by algebraic effects, the "mother of all monads".
/// <br/> 🔗 https://eiriktsarpalis.wordpress.com/2020/07/20/effect-programming-in-csharp/
/// <br/> 🔗 https://github.com/palladin/Eff
/// <br/> 🔗 https://github.com/brianberns/AlgEff
/// </para>
/// <para>
/// The <c>Program</c> is a <em>Monad</em> because it satisfies their laws:
/// <br/> 1. <em>Left identity:</em> <c>Stop x |> bind f</c> ≡ <c>f x</c>
/// <br/> 2. <em>Right identity:</em> <c>prog |> bind Stop</c> ≡ <c>prog</c>
/// <br/> 3. <em>Associativity:</em> <c>prog |> bind f |> bind g</c> ≡ <c>prog |> bind (f >> bind g)</c>
/// </para>
/// </remarks>
type Program<'ret> =
    /// Last step in a program, containing the resulting value.
    | Stop of 'ret

    /// One step in a program.
    | Effect of IProgramEffect<Program<'ret>>

[<AutoOpen>]
module ProgramBuilder =
    /// <summary>
    /// Binds the current <c>program</c> with the one generated by the <c>f</c> function.
    /// </summary>
    let rec private bind f program =
        match program with
        | Stop x -> f x
        | Effect effect -> effect.Map(bind f) |> Effect

    /// Bind operator
    let private (>>=) program f = bind f program

    let private bindResult (f: 'v -> Program<_>) (result: Result<'v, _>) =
        match result with
        | Ok v -> f v
        | Error e -> Stop(Error e)

    type ProgramBuilder() =
        member _.Zero() = Stop()
        member _.Return(value) = Stop value
        member _.ReturnFrom(value) = value
        member _.Bind(program: Program<_>, f) = program >>= f
        member _.Bind(program: Program<Result<_, _>>, f) = program >>= (bindResult f)
        member _.Bind(result: Result<_, _>, f) = result |> bindResult f // Useful to bind the result of a domain type smart constructor

    let program = ProgramBuilder()

[<RequireQualifiedAccess>]
module Program =
    /// Helper to simplify the definition of an effectful program instruction
    let inline effect (buildEffect: _ -> 'eff) (buildInstruction: _ -> Instruction<'arg, 'ret, _>) (args: 'arg) =
        let instructionName = typeof<'eff>.Name.Replace("Effect`1", "")
        Effect(buildEffect (buildInstruction (instructionName, args, Stop)))

    /// No Op program = doing nothing
    let inline noop () = program { return Ok() }

    let inline ok value = program { return Ok value }

    let map (f: 'a -> 'b) (prog: Program<'a>) =
        program {
            let! x = prog
            return f x
        }

    let mapError (f: 'error -> Error) (prog: Program<Result<_, 'error>>) =
        program {
            let! result = prog //here we retrieve return value from our program `prog`. Like async/await in C#
            return result |> Result.mapError f
        }

    let mapDataRelatedError prog = prog |> mapError DataError
    let mapResult f prog = map (Result.map f) prog

    let defaultValue value prog = prog |> map (Option.defaultValue value)
    let ignore prog = prog |> map Result.ignore

    let requireSome info (queryResult: Program<'a option>) = queryResult |> map (Result.requireSome info)
    let requireSomeData info (queryResult: Program<'a option>) = queryResult |> map (Result.requireSomeData info)

    /// Run the given command and return the eventual error without blocking the program
    let runCommandWithNonBlockingError (xProg: Program<Result<unit, 'e>>) =
        program {
            let! result = xProg
            return result |> Result.tryGetError
        }

[<Interface>]
type IDomain =
    abstract member Name: string

[<Interface>]
type IDomainWorkflow<'dom when 'dom :> IDomain> =
    abstract member Domain: 'dom

[<Interface>]
type IProgramWorkflow<'arg, 'ret> =
    abstract member Run: 'arg -> Program<Result<'ret, Error>>